#!/usr/bin/env python3

import os
import re
import requests
import json
import sys
import mutagen
import tempfile
import shutil
import urllib
import argparse
from mutagen.easyid3 import EasyID3
from mutagen.mp4 import MP4, MP4Cover
from mutagen.mp3 import EasyMP3
from mutagen.id3 import ID3, APIC, TIT2, TALB, TPE1, TPE2, COMM, USLT, TCOM, TCON, TDRC

'''
We have to use the client_id of another app as Soundcloud is no longer
taking requests for new user applications and therefore doesn't allow
us to create a new one that is made specifically for this program.
Instead, we have no other choice (if we don't want to keep updating the app
constantly) other than to use the client_id youtube-dl has embedded in
its source code. Can't believe I didn't think of this sooner (which is why it
kept breaking so freaking often).
'''
clientId = "FweeGBOOEOYJWLJN3oEyToGLKhmSz0I7"
appVersion = "1520423007"

def main():
    parseStuff()
    soundcloudUrl = input("Please enter a URL: ")
    #If the playlist flag is set just download it as a playlist right away,
    #otherwise just let the regex recide
    if playlistFlag == 1:
        if premiumFlag == 1:
            downloadPlaylist(soundcloudUrl, 1)
        if premiumFlag == 0:
            downloadPlaylist(soundcloudUrl, 0)
    if playlistFlag == 0:
        linkType, soundcloudUrl = linkDetection(soundcloudUrl)
        if linkType == 1 and premiumFlag == 1:
            downloadSingleTrack(soundcloudUrl, 1, 0)
        if linkType == 1 and premiumFlag == 0:
            downloadSingleTrack(soundcloudUrl, 0, 0)
        if linkType == 2 and premiumFlag == 1:
            downloadPlaylist(soundcloudUrl, 1)
        if linkType == 2 and premiumFlag == 0:
            downloadPlaylist(soundcloudUrl, 0)
    print("Done!")

def linkDetection(soundcloudUrl):
    '''
    detects the type of link, as a fallback for a lack of playlist flag
    return 1 = single track
    return 2 = playlist
    '''
    #Fix a missing https://
    httpsRegex = re.compile(r"^https:\/\/soundcloud\.com.{1,}$")
    if not (httpsRegex.match(soundcloudUrl)):
        soundcloudUrl = "{}{}".format(u"https://", soundcloudUrl)

    #Fix URL if it is a single track out of a playlist
    if '?in=' in soundcloudUrl:
        soundcloudUrl = soundcloudUrl.split('?in=')
        soundcloudUrl = soundcloudUrl[0]

    #URL is a playlist
    if '/sets' in soundcloudUrl:
        return 2, soundcloudUrl

    #URL for tracks of a user
    userReTracks1 = re.compile(r"^https:\/\/soundcloud.com\/[abcdefghijklmnopqrstuvwxyz\-_1234567890]{1,}$")
    userReTracks2 = re.compile(r"^https:\/\/soundcloud.com\/[abcdefghijklmnopqrstuvwxyz\-_1234567890]{1,25}\/tracks$")

    if (userReTracks1.match(soundcloudUrl)) or (userReTracks2.match(soundcloudUrl)):
        return 3, soundcloudUrl

    #URL for likes of a user
    userReLikes = re.compile(r"^https:\/\/soundcloud.com\/[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\-_1234567890]{1,}\/likes$")
    if (userReLikes.match(soundcloudUrl)):
        return 4, soundcloudUrl

    #This is a single track
    else:
        return 1, soundcloudUrl

def downloadSingleTrack(soundcloudUrl, hqFlag, optionalAlbum):
    '''
    If you're downloading a playlist a string containing the playlist
    name will be passed to the function as optionalAlbum, otherwise 
    it is 0 and gets replaced by simple string
    '''
    if optionalAlbum != 0:
        album = optionalAlbum
    else:
        album = "SoundCloud"

    '''
    m4a premium download, only happens when both flags are set
    '''
    if premiumFlag == 1 and hqFlag == 1:
        trackId = getTrackId(soundcloudUrl)
        try:
            downloadPremium(trackId)
            '''
            A failed m4a download results in an empty file
            due to the lack of audio streams, so we can just
            check for the filesize to see if the download was
            successful or not :)
            '''
            size = os.path.getsize(str(trackId) + ".m4a")
            print(size)
            if size != 0:
                '''
                Set flag in case the download failed
                '''
                m4aFailedFlag = 0
        except:
            pass

    '''
    if any 
    '''
    if premiumFlag == 0 or hqFlag == 0 or size == 0:
        '''
        Takes effect when the download either failed or the premium
        option wasn't chosen, downloads the regular 128kbps file
        '''
        m4aFailedFlag = 1
        trackId = getTrackId(soundcloudUrl)
        downloadRegular(trackId)

    '''
    The tagging procedure is similar for both file types, only
    the way the tags are applied is different.
    '''
    trackName, artist, coverFlag = getTags(soundcloudUrl)
    description = getDescription(soundcloudUrl)

    '''
    File gets renamed differently depending on whether or not it's
    an m4a or mp3, obviously
    '''
    if m4aFailedFlag == 1 or hqFlag == 0:
        renameFile(trackId, trackName, 0)
    else:
        renameFile(trackId, trackName, 1)


    if premiumFlag ==  1 and hqFlag == 1 and m4aFailedFlag == 0:
        '''
        m4a
        '''
        addTags(trackName, artist, album, coverFlag, description, 1)
    else:
        '''
        mp3
        '''
        addTags(trackName, artist, album, coverFlag, description, 0)

    cleanUp(trackId, repairFilename(trackName))

def repairFilename(trackName):
    '''
    Filenames are problematic, Windows, Linux and macOS don't
    allow certain characters. This (mess) fixes that. Basically 
    every other character, no matter how obscure, is seemingly
    supported though.
    '''

    if u"/" in trackName:
        trackName = trackName.replace(u"/", u"-")
    if u"\\" in trackName:
        trackName = trackName.replace(u"\\", u"-")
    if u"|" in trackName:
        trackName = trackName.replace(u"|", u"-")
    if u":" in trackName:
        trackName = trackName.replace(u":", u"-")
    if u"?" in trackName:
        trackName = trackName.replace(u"?", u"-")
    if u"<" in trackName:
        trackName = trackName.replace(u"<", u"-")
    if u">" in trackName:
        trackName = trackName.replace(u">", u"-")
    if u'"' in trackName:
        trackName = trackName.replace(u'"', u"-")
    if u"*" in trackName:
        trackName = trackName.replace(u"*", u"-")

    return trackName

def renameFile(trackId, trackName, premiumFlag):
    '''
    Using the trackId as the filename saves me lots
    of trouble compared to having to deal with the
    (sometimes) problematic titles as filenames.
    That way it's easier to just rename them afterwards.
    '''
    trackName = repairFilename(trackName)
    #We're dealing with a .m4a file here
    if premiumFlag == 1:    
        oldFilename = str(trackId) + '.m4a'
        newFilename = str(trackName) + '.m4a'
    #We're dealing with a .mp3 file here
    if premiumFlag == 0:
        oldFilename = str(trackId) + '.mp3'
        newFilename = str(trackName) + '.mp3'
    os.rename(oldFilename, newFilename)

def cleanUp(trackId, trackName):
    '''
    Removes all the leftover files, both the ones from the successful
    as well as the failed downloads which are basically just empty files
    '''

    os.system("rm -rf " + str(trackId) + ".*")
    os.system("rm -rf cover.jpg")
    os.system("find -name '" + str(trackId) + "*' -size 0 -delete")
    os.system("find -name '" + trackName + "*' -size 0 -delete")

def changeDirectory(folderName):
    '''
    makes directory with the name of the album passed to it, creates it if needed
    '''
    if "/" in folderName:
        folderName.replace("/","-")
    if not os.path.exists(folderName):
        os.makedirs(folderName)
        os.chdir(folderName)
    else:
        os.chdir(folderName)

def getTrackId(soundcloudUrl):
    '''
    Self-explanatory.
    '''
    resolveUrl = "https://api.soundcloud.com/resolve.json?url="
    url = str(resolveUrl) + str(soundcloudUrl) + str("&client_id=") + str(clientId)
    s = requests.get(url)
    s = s.content
    trackId = json.loads(s)
    trackId = trackId["id"]
    return trackId

def downloadPremium(trackId):
    '''
    saves the json file containing a link to the hls stream which
    contains the audio we want. I have no clue for how long this
    hacky solution will continue to work. Probably until I cancel
    my SoundCloud Go Plus subscription (or rather trial)
    '''
    curlPremiumJsonUrl = u"curl 'https://api-v2.soundcloud.com/tracks?ids=" + str(trackId) + u"&client_id=GSTMg2qyKgq8Ou9wvJfkxb3jk1ONIzvy&%5Bobject%20Object%5D=&app_version=1570441876&app_locale=de' -H 'Sec-Fetch-Mode: cors' -H 'Origin: https://soundcloud.com' -H 'Authorization: OAuth 2-290697-69920468-HvgOO5GJcVtYD39' -H 'Content-Type: application/json' -H 'Accept: application/json, text/javascript, */*; q=0.1' -H 'Referer: https://soundcloud.com/' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36' -H 'DNT: 1' --compressed > " + str(trackId) + u".txt"
    os.system(curlPremiumJsonUrl)
    jsonFilename = str(trackId) + u".txt"
    with open(jsonFilename) as f:
        data = json.loads(f.read())
        print(data[0]['media']['transcodings'][0]['url'])
        url = data[0]['media']['transcodings'][0]['url']
    url = url + "?client_id=GSTMg2qyKgq8Ou9wvJfkxb3jk1ONIzvy"

    '''
    In the words of Dillon Francis' alter ego DJ Hanzel: "van deeper"
    That link to the hls stream leads to yet another link, which
    contains yet another link, which contains...
    '''
    curlPremiumm3u8 = "curl '" + url + "' -H 'Sec-Fetch-Mode: cors' -H 'Referer: https://soundcloud.com/' -H 'Origin: https://soundcloud.com' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36' -H 'Authorization: OAuth 2-290697-69920468-HvgOO5GJcVtYD39' -H 'DNT: 1' --compressed > " + str(trackId) + ".txt"
    os.system(curlPremiumm3u8)
    m3u8Filename = str(trackId) + ".txt"
    with open(m3u8Filename) as f:
        data = json.loads(f.read())
        url = data['url']

    '''
    Yet another really hacky solution, gets the .m3u8 file using curl,
    it basically only replicates excactly what a browser would do (go
    look at the network tab in the explore tool and see for yourself)
    '''
    os.system("curl '" + url + "' -H 'Sec-Fetch-Mode: cors' -H 'Referer: https://soundcloud.com/' -H 'Origin: https://soundcloud.com' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36' -H 'Authorization: OAuth 2-290697-69920468-HvgOO5GJcVtYD39' -H 'DNT: 1' --compressed > " + str(trackId) + ".m3u8")

    '''
    Stitch the .m4a together using ffmpeg. Thank God I don't have to do this by hand.
    By the way, ffmpeg hates https so it needs to be whitelisted.
    '''
    ffmpegCommand = "ffmpeg -protocol_whitelist file,http,https,tcp,tls -i " + str(trackId) + ".m3u8 -c copy " + str(trackId) + ".m4a"
    os.system(ffmpegCommand)

def downloadRegular(trackId):
    '''
    Function for regular 128kbps mp3 files
    '''
    getMp3Url = "https://api.soundcloud.com/i1/tracks/" + str(trackId) + "/streams?client_id=" + clientId + "&app_version=" + appVersion
    mp3Url = requests.get(getMp3Url)
    '''
    Fix the URL somehow
    '''
    fileMp3Url = mp3Url.content[21:]
    urlSplit = fileMp3Url.split(b'"')
    fileMp3Url = urlSplit[0]
    #Python3 turned this into a bytes object for some reason
    fileMp3Url = fileMp3Url.decode("utf-8")
    filename = str(trackId) + ".mp3"
    urllib.request.urlretrieve(fileMp3Url, filename)

def getTags(soundcloudUrl):
    '''
    Get the big json file containing basically all the metadata using the API
    '''
    resolveUrl = u"https://api.soundcloud.com/resolve.json?url="
    a = requests.get(str(resolveUrl) + str(soundcloudUrl) + u"&client_id=" + str(clientId))
    a = a.content
    tags = json.loads(a)
    trackName = tags["title"]

    try:
        print("trackName: {}".format(trackName))
    except :
        print("ERROR: CANNOT DISPLAY TRACK NAME!")
        raise

    artist = tags["user"]["username"]

    print("artist: {}".format(artist))

    '''
    the json file doesn't reveal the biggest available cover art, 
    but we can fix that ourselves!
    '''
    cover = tags["artwork_url"]
    if cover is not None:
        coverFlag = 1
        cover = cover.replace("large", "t500x500")
        urllib.request.urlretrieve(cover, "cover.jpg")
        print("coverFlag: {}".format(coverFlag))

    else:
        '''
        some tracks don't have any kind of cover art, the
        avatar of the user is shown instead. We can implement that
        here. Once again the full size picture is not in the json file...
        '''
        coverFlag = 1
        cover = tags["user"]["avatar_url"]
        cover = cover.replace("large", "t500x500")
        #cover_request = requests.get(cover, stream=True)
        #cover_file = cover_request.raw
        urllib.request.urlretrieve(cover, "cover.jpg")
        print("coverFlag: {}".format(coverFlag))

    return trackName, artist, coverFlag

def getDescription(soundcloudUrl):
    '''
    gets the description separately
    '''
    resolveUrl = "https://api.soundcloud.com/resolve.json?url="
    a = requests.get(resolveUrl + soundcloudUrl + "&client_id=" + clientId)
    a = a.content
    tags = json.loads(a)
    description = tags["description"]
    return description

def addTags(trackName, artist, album, coverFlag, description, m4aFlag):
    '''
    Adds tags to the M4A file. 
    All of these are supported by iTunes and should
    therefore not cause much trouble with other media
    players. If you're downloading a playlist, then the
    album name will be the name of the playlist instead of
    "SoundCloud"
    '''
    if m4aFlag == 1:
        repairedFilename = repairFilename(trackName)
        tags = MP4(repairedFilename + ".m4a").tags
        tags["desc"] = description
        tags["\xa9nam"] = trackName
        if album is not 0:
            tags["\xa9alb"] = album
        else:
            tags["\xa9alb"] = "SoundCloud"
        tags["\xa9ART"] = artist

        with open("cover.jpg", "rb") as f:
            tags["covr"] = [
                MP4Cover(f.read(), imageformat=MP4Cover.FORMAT_JPEG)
            ]
        tags.save(repairedFilename + ".m4a")



    if m4aFlag == 0:
        repairedFilename = repairFilename(trackName)
        audio = EasyMP3(repairedFilename + ".mp3")
        audio['title'] = trackName
        audio['artist'] = artist

        if album is not 0:
            audio['album'] = album
        else:
            audio['album'] = u"SoundCloud"
        audio.save(v2_version=3)

        if coverFlag is not 0:
            audio = ID3(str(repairedFilename) + u".mp3")
            audio.add(
            USLT(
                encoding=3,
                lang=u'eng',
                desc=u'desc',
                text=description
                )
            )
            with open('cover.jpg', 'rb') as albumart:     
                audio.add(
                APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=albumart.read()
                    )
                )
            audio.add(
            COMM(
                encoding=3,
                text=description
                )
            )
            audio.save(v2_version=3)

def downloadPlaylist(soundcloudUrl, hqFlag):
    playlistId = getPlaylistId(soundcloudUrl)
    print("Playlist ID: {}".format(playlistId))
    permalinkUrl, trackId, trackName, album, trackCount = getPlaylistTracks(playlistId)
    description = getPlaylistDescriptions(playlistId)
    changeDirectory(album)

    for index in range(trackCount):
        downloadSingleTrack(permalinkUrl[index], hqFlag, album)

def getPlaylistId(soundcloudUrl):
    '''
    The name says it all, that's really al there is to it.
    '''
    resolveUrl = u"https://api-mobi.soundcloud.com/resolve?permalink_url=" + soundcloudUrl + u"&client_id=" + clientId + u"&format=json&app_version=" + appVersion
    playlistIdRequest = requests.get(resolveUrl).content
    playlistIdRequest = json.loads(playlistIdRequest)
    return playlistIdRequest["id"]

def getPlaylistTracks(playlistId):
    '''
    Gets the links to all the tracks in a playlist together with their
    names as well as their IDs, all of which are necessary to download
    the track seamlessly.
    '''
    playlistApiUrl = "http://api.soundcloud.com/playlists/" + str(playlistId) + "?client_id=" + str(clientId)
    playlistUrls = requests.get(playlistApiUrl)
    permalinkUrls = json.loads(playlistUrls.content)
    album = permalinkUrls["title"]
    permalinkUrl = []
    trackId = []
    trackTitle = []
    trackCount = int(permalinkUrls["track_count"])

    for i in range(trackCount):
        permalinkUrl.append(i)
        trackId.append(i)
        trackTitle.append(i)
        permalinkUrl[i] = permalinkUrls["tracks"][i]["permalink_url"]
        trackId[i] = permalinkUrls["tracks"][i]["id"]
        trackTitle[i] = permalinkUrls["tracks"][i]["title"]

    return permalinkUrl, trackId, trackTitle, album, trackCount    

def getPlaylistDescriptions(playlistId):
    '''
    Get individual descriptions for all the track in a playlist.
    I have yet to figure out why the getTags function refuses
    to pass the description string as an argument but this 
    seprate function works just fine for the time being. Sure,
    it's not efficient but one more API request on top of countless
    other ones won't hurt.
    '''
    playlistApiUrl = "http://api.soundcloud.com/playlists/" + str(playlistId) + "?client_id=" + str(clientId)
    playlistUrls = requests.get(playlistApiUrl)
    permalinkUrls = json.loads(playlistUrls.content)
    description = []
    trackCount = int(permalinkUrls["track_count"])

    for i in range(trackCount):
        description.append(i)
        description[i] = permalinkUrls["tracks"][i]["description"]

    return description    

def parseStuff():
    '''
    Checks for two arguments, --pl for a playlist link and
    -p for the m4a download. If the playlist flag isn't present
    it just uses a simple regex as a fallback. If the premium flag
    isn't present scdl will simply download the 128kbps MP3 available
    for everyone else that isn't a SCG+ subscriber.
    '''
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p','--premium',
        help="Use if you are a subscriber to SoundCloud Go Plus",
        action="store_const",
        dest="premium",
        const="soundcloudgoplus",
        )
    parser.add_argument(
        '-pl','--playlist',
        help="Download a playlist instead of a single track",
        action="store_const",
        dest="playlistFlag",
        const="1",
        )
    args = parser.parse_args()
    if args.premium:
        global premiumFlag
        premiumFlag = 1
        print("Premium!")
    if args.playlistFlag:
        global playlistFlag
        playlistFlag = 1
        print("Downloading a playlist!")
    if args.playlistFlag is None:
        playlistFlag = 0

if __name__ == '__main__':
    main()